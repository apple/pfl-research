<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="article:modified_time" content="2024-01-27T22:28:45+00:00" /><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="prev" title="Privacy loss bound" href="privacy_loss_bound.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2023.09.10 -->
        <title>Tree - pfl 0.3.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">pfl 0.3.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">pfl 0.3.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Getting Started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../guides/fl_introduction.html">Federated learning with pfl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/simulation_distributed.html">Fast distributed simulations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support/contributing.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../algorithm.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aggregate.html">Backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aggregate.html#aggregator">Aggregator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aggregate.html#module-pfl.aggregate.data_transport">Data transport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aggregate.html#module-pfl.aggregate.weighting">Weighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../callback.html">Callbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../common_types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../exception.html">Exception</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hyperparam.html">Hyperparameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../model.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../postprocessor.html">Postprocessor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../privacy.html">Differential privacy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stats.html">Training statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tree.html">Gradient boosted decision trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../environment_variables.html">Environment variables</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Internal API</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Internal API</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="bisect.html">Bisect</a></li>
<li class="toctree-l2"><a class="reference internal" href="bridge.html">Bridges</a></li>
<li class="toctree-l2"><a class="reference internal" href="distribution.html">Distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="ops.html">Ops</a></li>
<li class="toctree-l2"><a class="reference internal" href="platform.html">Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="privacy_loss_bound.html">Privacy loss bound</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Tree</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="tree">
<h1>Tree<a class="headerlink" href="#tree" title="Link to this heading">#</a></h1>
<section id="module-pfl.internal.tree.gbdt">
<span id="tree-data-structs"></span><h2>Tree data structs<a class="headerlink" href="#module-pfl.internal.tree.gbdt" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt.</span></span><span class="sig-name descname"><span class="pre">GBDT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT" title="Link to this definition">#</a></dt>
<dd><p>Gradient Boosted Decision Tree base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Default value for all datapoints before any trees are trained and added
to a GBDT. When trees have been added to a GBDT, the prediction for a
datapoint is base_value + sum of leaf values assigned to a datapoint
from each tree in a GBDT.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT.add_tree">
<span class="sig-name descname"><span class="pre">add_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT.add_tree" title="Link to this definition">#</a></dt>
<dd><p>Add the root node of a fully or partially trained tree to the GBDT.</p>
<p>This will be the root node of a new tree in the GBDT ensemble of trees.
Ensure the previous tree in the GBDT is fully trained before adding a
new tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<a class="reference internal" href="#pfl.internal.tree.node.Node" title="pfl.internal.tree.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a>) – Root node of a fully or partially trained tree to be added to GBDT.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT.get_max_min_predictions">
<span class="sig-name descname"><span class="pre">get_max_min_predictions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT.get_max_min_predictions" title="Link to this definition">#</a></dt>
<dd><p>Return the maximum and minimum predictions possible from a GBDT.</p>
<p>Maximum prediction = sum of highest value leaf from each tree in GBDT
plus base value. Minimum prediction = sum of lowest value leaf from
each tree in GBDT plus base value.</p>
<p>Only consider trees in GBDT which are fully trained.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Maximum possible prediction from GBDT,
Minimum possible prediction from GBDT.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT.predict" title="Link to this definition">#</a></dt>
<dd><p>Make prediction for each datapoint in X using all fully trained trees
in GBDT.</p>
<p>The prediction of a datapoint from a GBDT is the sum of the values
assigned to a datapoint from each tree in the GBDT plus the base value.</p>
<p>If a GBDT is empty, the prediction of a datapoint is the base value.</p>
<p>Only fully trained trees in a GBDT are considered during prediction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Prediction from GBDT for each datapoint in X.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT.to_serialized_xgboost">
<span class="sig-name descname"><span class="pre">to_serialized_xgboost</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT.to_serialized_xgboost" title="Link to this definition">#</a></dt>
<dd><p>Emulate output of xgboost dump_model() method.</p>
<p>Returns a dictionary describing the GBDT, which looks the same as the
model description from the xgboost dump_model() method, see
<a class="reference external" href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.Booster.dump_model">https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.Booster.dump_model</a></p>
<p>Only fully trained trees in GBDT will be converted to XGBoost format.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dictionary describing GBDT, in the format of XGBoost’s dump_model()
function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDT.evaluate">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDT.evaluate" title="Link to this definition">#</a></dt>
<dd><p>Compute performance metrics for GBDT on datapoints in X, given targets
in y.</p>
<p>Only fully trained trees in GBDT will be considered during evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Targets corresponding to datapoints in X: array-like, of shape
(N,) or (N, 1), where N is the number of datapoints.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary of performance metrics, evaluating GBDT on datapoints
in X, given targets y.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTClassifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt.</span></span><span class="sig-name descname"><span class="pre">GBDTClassifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTClassifier" title="Link to this definition">#</a></dt>
<dd><p>Gradient Boosted Decision Tree class for binary classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Default value for all datapoints before any trees are trained and added
to a GBDT. When trees have been added to a GBDT, the prediction for a
datapoint is base_value + sum of leaf values assigned to a datapoint
from each tree in a GBDT.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTClassifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTClassifier.predict" title="Link to this definition">#</a></dt>
<dd><p>Make prediction for each datapoint in X using all fully trained trees
in GBDT.</p>
<p>The prediction of a datapoint from a classification GBDT is the sigmoid
of the sum of the values assigned to that datapoint from each tree in
the GBDT plus the base value.</p>
<p>If a GBDT is empty, the prediction of a datapoint is the sigmoid of the
base value of the GBDT.</p>
<p>Only fully trained trees in a GBDT are considered for prediction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Prediction from GBDT for each datapoint in X.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTClassifier.predict_classes">
<span class="sig-name descname"><span class="pre">predict_classes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTClassifier.predict_classes" title="Link to this definition">#</a></dt>
<dd><p>Make binary class prediction for each datapoint in X using all fully
trained trees in GBDT.</p>
<p>The class prediction is the prediction rounded to the nearest class of
0 and 1. Predictions in range (-inf, 0.5] map to class 0. Predictions
in range (0.5, +inf) map to class 1. Note that the prediction used
to calculate the class is the sigmoid of the sum of the values assigned
to the datapoint from each tree in the GBDT plus the base value.</p>
<p>Only fully trained trees in GBDT will be considered for prediction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Prediction from GBDT for each datapoint in X.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTClassifier.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTClassifier.evaluate" title="Link to this definition">#</a></dt>
<dd><p>Compute accuracy of GBDT binary classifier on data X, given targets y.</p>
<p>Evaluation will only be performed on fully trained trees in GBDT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Targets corresponding to datapoints in X: array-like, of shape
(N,) or (N, 1), where N is the number of datapoints.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary of metrics, including accuracy of GBDT on data X, with
targets y.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTClassifier.get_max_min_predictions">
<span class="sig-name descname"><span class="pre">get_max_min_predictions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTClassifier.get_max_min_predictions" title="Link to this definition">#</a></dt>
<dd><p>Return the maximum and minimum predictions possible from a GBDT.</p>
<p>Maximum prediction = expit of sum of highest value leaf from each tree
in GBDT plus base value. Minimum prediction = expit of sum of lowest
value leaf from each tree in GBDT plus base value.</p>
<p>Only consider trees in GBDT which are fully trained.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Maximum possible prediction from GBDT,
Minimum possible prediction from GBDT.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTRegressor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt.</span></span><span class="sig-name descname"><span class="pre">GBDTRegressor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTRegressor" title="Link to this definition">#</a></dt>
<dd><p>Gradient Boosted Decision Tree class for regression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_features</strong> – Number of features of datapoints used to train GBDT.</p></li>
<li><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Default value for all datapoints before any trees are trained and added
to a GBDT. When trees have been added to a GBDT, the prediction for a
datapoint is base_value + sum of leaf values assigned to a datapoint
from each tree in a GBDT.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt.GBDTRegressor.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt.GBDTRegressor.evaluate" title="Link to this definition">#</a></dt>
<dd><p>Compute mean-absolute error (MAE), and mean-squared error (MSE) of
regression GBDT, given data X and targets y.</p>
<p>Evaluation will only be performed on fully trained trees in GBDT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints,
and d is the number of features per datapoint.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Targets corresponding to datapoints in X: array-like, of shape
(N,) or (N, 1), where N is the number of datapoints.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dictionary of metrics, including MAE and MSE of GBDT on data X,
with targets y.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class" id="module-pfl.internal.tree.node">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.node.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_child</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_child</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node" title="Link to this definition">#</a></dt>
<dd><p>Represents a branch node or a leaf node in a binary decision tree.</p>
<p>A branch node has a left child node and right child node, and is defined
by an inequality: feature &lt;= threshold. A datapoint follows the path to the
left child node if the inequality is satisfied for this datapoint. Else,
a datapoint follows the path to the right child node.</p>
<p>A leaf node has no left or right child node. It is defined by a value.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.is_leaf">
<span class="sig-name descname"><span class="pre">is_leaf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.is_leaf" title="Link to this definition">#</a></dt>
<dd><p>Check if node is a leaf node.</p>
<p>A leaf node has a value and does not have a left or a right child node.</p>
<p>If a node does not have a left or a right child node, but does not have
a value, it is just an incomplete branch node, with no child nodes
attached yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if node is a leaf node, else False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.num_nodes">
<span class="sig-name descname"><span class="pre">num_nodes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.num_nodes" title="Link to this definition">#</a></dt>
<dd><p>Return number of nodes in tree, starting with current node.</p>
<p>The tree does not have to be fully trained to call this function.</p>
<p>Either value must be set, or feature and threshold must be set for a
node to be counted.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.max_depth">
<span class="sig-name descname"><span class="pre">max_depth</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.max_depth" title="Link to this definition">#</a></dt>
<dd><p>Return maximum depth of tree: the number of nodes along the longest
path in the tree.</p>
<p>The tree does not have to be fully trained to call this function.</p>
<p>Either value must be set, or feature and threshold must be set for a
node to be counted.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Maximum depth of tree from current node.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.add_leaf_node">
<span class="sig-name descname"><span class="pre">add_leaf_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.add_leaf_node" title="Link to this definition">#</a></dt>
<dd><p>Add a leaf child node to this node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, leaf node is left child of parent node.
Else, leaf node is right child of parent node.</p></li>
<li><p><strong>value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Value of leaf node, used for predictions.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.add_branch_node">
<span class="sig-name descname"><span class="pre">add_branch_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">is_left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.add_branch_node" title="Link to this definition">#</a></dt>
<dd><p>Add a branch child node to this node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>is_left</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, branch node is left child of parent node.
Else, branch node is right child of parent node.</p></li>
<li><p><strong>feature</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Feature used for inequality condition at branch node.</p></li>
<li><p><strong>threshold</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Threshold used for inequality condition at branch node.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pfl.internal.tree.node.Node" title="pfl.internal.tree.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Branch child node just added.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.training_complete">
<span class="sig-name descname"><span class="pre">training_complete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.training_complete" title="Link to this definition">#</a></dt>
<dd><p>Returns whether tree, including this node and all child nodes, is
completely trained or not.</p>
<p>Tree is completely trained if it is a full binary tree: every node
other than the leaf nodes have 2 child nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.get_leaf_values">
<span class="sig-name descname"><span class="pre">get_leaf_values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.get_leaf_values" title="Link to this definition">#</a></dt>
<dd><p>Return list of values of all leaves in tree.</p>
<p>Tree can be fully or partially trained when this method is called.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.predict" title="Link to this definition">#</a></dt>
<dd><p>Make prediction for each datapoint in X using tree.</p>
<p>Each datapoint is passed through the tree, following the decision path
arising from the inequality condition at each branch node, until each
datapoint arrives at a leaf node, whose value is the prediction for
this datapoint.</p>
<p>If the tree is empty, return the base prediction for all datapoints.</p>
<p>The tree must be fully trained to return a prediction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – (N x d) array of datapoints, where N is the number of datapoints
and d is the number of features per datapoint.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Prediction from tree for each datapoint in X.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.to_serialized_xgboost">
<span class="sig-name descname"><span class="pre">to_serialized_xgboost</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.to_serialized_xgboost" title="Link to this definition">#</a></dt>
<dd><p>Emulate xgboost’s dump_model() function.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Nested dictionary describing the nodes in a tree.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.node.Node.from_serialized_xgboost">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_serialized_xgboost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.Node.from_serialized_xgboost" title="Link to this definition">#</a></dt>
<dd><p>Extra tree from serialized xgboost format.
Use depth-first search to process all nodes in tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tree</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>) – Dictionary representing tree, in serialized
XGBoost format.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pfl.internal.tree.node.Node" title="pfl.internal.tree.node.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return root node of tree.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pfl.internal.tree.node.process_xgboost_node">
<span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.node.</span></span><span class="sig-name descname"><span class="pre">process_xgboost_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.node.process_xgboost_node" title="Link to this definition">#</a></dt>
<dd><p>Process a node in serialized xgboost format.</p>
<dl class="simple">
<dt>:param node</dt><dd><p>Serialized XGBoost dictionary format for node.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple of (feature, threshold, value) describing node.
Note that if node is a branch node, Value will be None.
Else if node is a leaf node, Feature and Threshold will
be None.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-pfl.internal.tree.gbdt_adaptive_hyperparameters">
<span id="gbdt-adaptive-hyperparameters"></span><h2>GBDT adaptive hyperparameters<a class="headerlink" href="#module-pfl.internal.tree.gbdt_adaptive_hyperparameters" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt_adaptive_hyperparameters.</span></span><span class="sig-name descname"><span class="pre">GBDTAdaptiveHyperparameter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter" title="Link to this definition">#</a></dt>
<dd><p>Base class for hyperparameters which are adapted during PFL of a GBDT using
the GBDT model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>base_value</strong> – Default value for hyperparameter.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter.current_value">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">current_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter.current_value" title="Link to this definition">#</a></dt>
<dd><p>Current value of hyperparameter, which is a function of base value, and
the GBDT model.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt_adaptive_hyperparameters.</span></span><span class="sig-name descname"><span class="pre">TrainCohortSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">per_layer_modifier_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'power'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_nodes_reduction_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize" title="Link to this definition">#</a></dt>
<dd><p>Cohort size used for training each level of a tree in a GBDT.</p>
<p>Default method for adapting training cohort size per layer of trees in GBDT
is the “power” method, which ensures the signal-to-noise ratio (SNR) is not
reduced when training deeper layers of the trees in a GBDT.</p>
<p>Note that fewer results are required to compute the values of leaf nodes,
as fewer training statistics are aggregated to compute this value.
Consequently, the cohort size for training leaf nodes is reduced compared
to the base value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Initial value for training cohort size. Gradients from this number of
users are aggregated to train root node, at top level of a tree in a
GBDT. This base value is selected to balance the tradeoff between final
performance of the trained model, the DP guarantees used during
training, and the time required to wait to aggregate this number of
results.</p></li>
<li><p><strong>per_layer_modifier_function</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Define function to use to modify the base value of the training cohort
size depending on the layer of a tree being trained. Options include
{‘none’, ‘linear’, ‘power’}, which, respectively, correspond to: not
adapting the cohort size; linearly increasing the cohort size with the
layer being trained; exponentially increase the cohort size with the
layer being trained. ‘power’ is the default setting, as this helps to
ensure that SNR does not reduce with the tree depth of the tree being
trained.</p></li>
<li><p><strong>leaf_nodes_reduction_factor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Defines the factor by which to reduce the training cohort size from
the base value when training the maximum depth of the tree, which
comprises only leaf nodes. The default value is 1, i.e. no reduction
takes place. However, this can be set to
<cite>total_num_questions/2^(max_depth - 1)</cite>, where <cite>total_num_questions</cite> is
the sum of the number of questions specified for each feature used for
training.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize.current_value">
<span class="sig-name descname"><span class="pre">current_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize.current_value" title="Link to this definition">#</a></dt>
<dd><p>Current value of hyperparameter, which is a function of base value, and
the GBDT model.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt_adaptive_hyperparameters.</span></span><span class="sig-name descname"><span class="pre">ValidationCohortSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize" title="Link to this definition">#</a></dt>
<dd><p>Validation is only performed once per tree being trained.</p>
<p>As trees are trained layer-wise, validation is only performed while
training the top layer of the tree. This is because the model’s predictions
will not change until an entire new tree is trained.</p>
<p>Future enhancement:
<a class="reference external" href="rdar://104295602">rdar://104295602</a> (GBDT evaluation should occur at lowest level of tree,
when largest training cohort size is used)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of users from which to gather metrics during validation
iterations.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize.current_value">
<span class="sig-name descname"><span class="pre">current_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize.current_value" title="Link to this definition">#</a></dt>
<dd><p>Current value of hyperparameter, which is a function of base value, and
the GBDT model.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt_adaptive_hyperparameters.</span></span><span class="sig-name descname"><span class="pre">ClippingBound</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tree_multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound" title="Link to this definition">#</a></dt>
<dd><p>Adapt clipping bound based on current layer and current index of tree being
trained in a GBDT.</p>
<p>The sensitivity of the vector of gradients gets smaller as training
progresses due to smaller gradients as predictions improve. Adapting the
clipping bound during training improves the SNR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Default value for clipping bound</p></li>
<li><p><strong>layer_multiplier</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Factor used to modify the base value for clipping bound depending on
the layer of a tree being trained. Should be in range (0, 1].</p></li>
<li><p><strong>tree_multiplier</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Factor used to modify the base value for clipping bound depending on
the layer of a tree being trained. Should be in range (0, 1].</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound.current_value">
<span class="sig-name descname"><span class="pre">current_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound.current_value" title="Link to this definition">#</a></dt>
<dd><p>Current value of hyperparameter, which is a function of base value, and
the GBDT model.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.gbdt_adaptive_hyperparameters.</span></span><span class="sig-name descname"><span class="pre">ComputeSecondOrderGradients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients" title="Link to this definition">#</a></dt>
<dd><p>Decide whether or not to compute and aggregate second order gradients
during training of a GBDT.</p>
<p>Second order gradients improve the algorithm’s ability to identify the
optimal split for a branch node, or value for a leaf node in a tree.
However, including second order gradients in the vector of gradients being
aggregated during training increases the sensitivity of this vector, which
means that the clipping for DP reduces the sensitivity by a greater factor
which can result in lower SNR during training.</p>
<p>Note that second order gradients must be aggregated for leaf nodes, in
order that leaf values can be computed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>base_value</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Default setting of whether to aggregate second order gradients during
training of a tree.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients.current_value">
<span class="sig-name descname"><span class="pre">current_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients.current_value" title="Link to this definition">#</a></dt>
<dd><p>Current value of hyperparameter, which is a function of base value, and
the GBDT model.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-pfl.internal.tree.questions">
<span id="tree-split-questions"></span><h2>Tree split questions<a class="headerlink" href="#module-pfl.internal.tree.questions" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.QuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">QuestionGenerator</span></span><a class="headerlink" href="#pfl.internal.tree.questions.QuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Abstract base class for generating questions to be used in training a GBDT
with a federated algorithm.</p>
<p>A question is defined as a “threshold” value, which is used to separate
data points into two subsets: (1) where datapoint[feature] &lt;= threshold;
and (2) where  datapoint[feature] &gt; threshold.</p>
<p>The questions must be returned as an increasing sorted list.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.QuestionGenerator.generate">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.QuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>Generate questions to be asked for a feature in the federated
algorithm to train a GBDT.</p>
<p>Questions generated should be in the range [<cite>min_val</cite>, <cite>max_val</cite>]. The
number of questions generated should be equal to <cite>num_questions</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.FloatEquidistantQuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">FloatEquidistantQuestionGenerator</span></span><a class="headerlink" href="#pfl.internal.tree.questions.FloatEquidistantQuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Generate questions for a feature of type float. The questions should be
spaced equidistantly between <cite>min_val</cite> and <cite>max_val</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.FloatEquidistantQuestionGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.FloatEquidistantQuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>Generate questions to be asked for a feature in the federated
algorithm to train a GBDT.</p>
<p>Questions generated should be in the range [<cite>min_val</cite>, <cite>max_val</cite>]. The
number of questions generated should be equal to <cite>num_questions</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.IntEquidistantQuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">IntEquidistantQuestionGenerator</span></span><a class="headerlink" href="#pfl.internal.tree.questions.IntEquidistantQuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Generate questions for a feature of type int. The questions should be
spaced equidistantly between <cite>min_val</cite> and <cite>max_val</cite>. For features of type
<cite>int</cite>, there should only be one question for the same integral part.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.IntEquidistantQuestionGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.IntEquidistantQuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>Generate questions to be asked for a feature in the federated
algorithm to train a GBDT.</p>
<p>Questions generated should be in the range [<cite>min_val</cite>, <cite>max_val</cite>]. The
number of questions generated should be equal to <cite>num_questions</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.FloatRandomQuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">FloatRandomQuestionGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.FloatRandomQuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Generate questions for a feature of type float. The questions are randomly
chosen in the range [<cite>min_val+offset</cite>, <cite>max_val-offset</cite>].</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.FloatRandomQuestionGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.FloatRandomQuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>Generate questions to be asked for a feature in the federated
algorithm to train a GBDT.</p>
<p>Questions generated should be in the range [<cite>min_val</cite>, <cite>max_val</cite>]. The
number of questions generated should be equal to <cite>num_questions</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.IntRandomQuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">IntRandomQuestionGenerator</span></span><a class="headerlink" href="#pfl.internal.tree.questions.IntRandomQuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Generate questions for a feature of type int. The questions are randomly
selected from the range[<cite>min_val</cite>, <cite>max_val</cite>], and there should only be one
question for the same integral part.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.IntRandomQuestionGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.IntRandomQuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>Generate questions to be asked for a feature in the federated
algorithm to train a GBDT.</p>
<p>Questions generated should be in the range [<cite>min_val</cite>, <cite>max_val</cite>]. The
number of questions generated should be equal to <cite>num_questions</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.BoolQuestionGenerator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pfl.internal.tree.questions.</span></span><span class="sig-name descname"><span class="pre">BoolQuestionGenerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">false_val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">true_val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.BoolQuestionGenerator" title="Link to this definition">#</a></dt>
<dd><p>Generate a single question for a Boolean variable. Only one question will
be generated, and this will lie at the midpoint of the range [<cite>false_val</cite>,
<cite>true_val</cite>] for the Boolean variable.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pfl.internal.tree.questions.BoolQuestionGenerator.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_val</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_questions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pfl.internal.tree.questions.BoolQuestionGenerator.generate" title="Link to this definition">#</a></dt>
<dd><p>If a split already exists on a Boolean feature, don’t generate a new
question, since it will not be able to further separate data. An
existing split will be identified when <cite>min_val</cite> &gt; <cite>self._false_val</cite>,
and/or <cite>max_val</cite> &gt; <cite>self._true_val</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="privacy_loss_bound.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Privacy loss bound</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024 Apple Inc.
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Jan 27, 2024</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Tree</a><ul>
<li><a class="reference internal" href="#module-pfl.internal.tree.gbdt">Tree data structs</a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT"><code class="docutils literal notranslate"><span class="pre">GBDT</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT.add_tree"><code class="docutils literal notranslate"><span class="pre">GBDT.add_tree()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT.get_max_min_predictions"><code class="docutils literal notranslate"><span class="pre">GBDT.get_max_min_predictions()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT.predict"><code class="docutils literal notranslate"><span class="pre">GBDT.predict()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT.to_serialized_xgboost"><code class="docutils literal notranslate"><span class="pre">GBDT.to_serialized_xgboost()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDT.evaluate"><code class="docutils literal notranslate"><span class="pre">GBDT.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTClassifier"><code class="docutils literal notranslate"><span class="pre">GBDTClassifier</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTClassifier.predict"><code class="docutils literal notranslate"><span class="pre">GBDTClassifier.predict()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTClassifier.predict_classes"><code class="docutils literal notranslate"><span class="pre">GBDTClassifier.predict_classes()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTClassifier.evaluate"><code class="docutils literal notranslate"><span class="pre">GBDTClassifier.evaluate()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTClassifier.get_max_min_predictions"><code class="docutils literal notranslate"><span class="pre">GBDTClassifier.get_max_min_predictions()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTRegressor"><code class="docutils literal notranslate"><span class="pre">GBDTRegressor</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt.GBDTRegressor.evaluate"><code class="docutils literal notranslate"><span class="pre">GBDTRegressor.evaluate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node"><code class="docutils literal notranslate"><span class="pre">Node</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.is_leaf"><code class="docutils literal notranslate"><span class="pre">Node.is_leaf()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.num_nodes"><code class="docutils literal notranslate"><span class="pre">Node.num_nodes()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.max_depth"><code class="docutils literal notranslate"><span class="pre">Node.max_depth()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.add_leaf_node"><code class="docutils literal notranslate"><span class="pre">Node.add_leaf_node()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.add_branch_node"><code class="docutils literal notranslate"><span class="pre">Node.add_branch_node()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.training_complete"><code class="docutils literal notranslate"><span class="pre">Node.training_complete()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.get_leaf_values"><code class="docutils literal notranslate"><span class="pre">Node.get_leaf_values()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.predict"><code class="docutils literal notranslate"><span class="pre">Node.predict()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.to_serialized_xgboost"><code class="docutils literal notranslate"><span class="pre">Node.to_serialized_xgboost()</span></code></a></li>
<li><a class="reference internal" href="#pfl.internal.tree.node.Node.from_serialized_xgboost"><code class="docutils literal notranslate"><span class="pre">Node.from_serialized_xgboost()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.node.process_xgboost_node"><code class="docutils literal notranslate"><span class="pre">process_xgboost_node()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pfl.internal.tree.gbdt_adaptive_hyperparameters">GBDT adaptive hyperparameters</a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter"><code class="docutils literal notranslate"><span class="pre">GBDTAdaptiveHyperparameter</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.GBDTAdaptiveHyperparameter.current_value"><code class="docutils literal notranslate"><span class="pre">GBDTAdaptiveHyperparameter.current_value()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize"><code class="docutils literal notranslate"><span class="pre">TrainCohortSize</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.TrainCohortSize.current_value"><code class="docutils literal notranslate"><span class="pre">TrainCohortSize.current_value()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize"><code class="docutils literal notranslate"><span class="pre">ValidationCohortSize</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ValidationCohortSize.current_value"><code class="docutils literal notranslate"><span class="pre">ValidationCohortSize.current_value()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound"><code class="docutils literal notranslate"><span class="pre">ClippingBound</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ClippingBound.current_value"><code class="docutils literal notranslate"><span class="pre">ClippingBound.current_value()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients"><code class="docutils literal notranslate"><span class="pre">ComputeSecondOrderGradients</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.gbdt_adaptive_hyperparameters.ComputeSecondOrderGradients.current_value"><code class="docutils literal notranslate"><span class="pre">ComputeSecondOrderGradients.current_value()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-pfl.internal.tree.questions">Tree split questions</a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.QuestionGenerator"><code class="docutils literal notranslate"><span class="pre">QuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.QuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">QuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.questions.FloatEquidistantQuestionGenerator"><code class="docutils literal notranslate"><span class="pre">FloatEquidistantQuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.FloatEquidistantQuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">FloatEquidistantQuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.questions.IntEquidistantQuestionGenerator"><code class="docutils literal notranslate"><span class="pre">IntEquidistantQuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.IntEquidistantQuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">IntEquidistantQuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.questions.FloatRandomQuestionGenerator"><code class="docutils literal notranslate"><span class="pre">FloatRandomQuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.FloatRandomQuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">FloatRandomQuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.questions.IntRandomQuestionGenerator"><code class="docutils literal notranslate"><span class="pre">IntRandomQuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.IntRandomQuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">IntRandomQuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pfl.internal.tree.questions.BoolQuestionGenerator"><code class="docutils literal notranslate"><span class="pre">BoolQuestionGenerator</span></code></a><ul>
<li><a class="reference internal" href="#pfl.internal.tree.questions.BoolQuestionGenerator.generate"><code class="docutils literal notranslate"><span class="pre">BoolQuestionGenerator.generate()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=4621528c"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>